#!/usr/bin/env python
# PSMCFa_converter 0.0.1
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# See http://wiki.dnanexus.com/Developer-Portal for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import os
import dxpy
import sys
import subprocess
import re
from math import ceil, floor
import gzip

def loadSeq(filename):
    """This loades the sequence from the consensus file.
    """
    f = gzip.open(filename, 'rb')
    line = f.readline()
    line = line.strip()
    mystart = int(line[1:])
    seq = ''
    for line in f:
        line = line.strip()
        if line[0] == '>': continue
        seq += line
    f.close()
    return (mystart, seq)

def windowElement(s1, s2, mp):
    """This computes the window element 
    given the 2 seqs and the prop of missing
    tolerated
    """
    missLim = floor(mp*len(s1))
    for i, j in zip(s1, s2):
        if (i == 'N' or j == 'N'):
            missLim -= 1
            if (missLim < 0):
                return 'N'
        elif i != j:
            return 'K'
    return 'T'

@dxpy.entry_point('main')
def main(file1, file2, outname):

    # The following line(s) initialize your data object inputs on the platform
    # into dxpy.DXDataObject instances that you can start using immediately.

    file1 = dxpy.DXFile(file1)
    file2 = dxpy.DXFile(file2)

    # The following line(s) download your file inputs to the local file system
    # using variable names for the filenames.

    dxpy.download_dxfile(file1.get_id(), "file1")
    dxpy.download_dxfile(file2.get_id(), "file2")

    # Fill in your application code here.
    (st1, seq1) = loadSeq('file1')
    print 'Loaded sequence 1'
    (st2, seq2) = loadSeq('file2')
    print outname

    skip = 100
    miss = 0.05    

    thisStart = st1
    if(st1 < st2):
        seq1 = seq1[(st2-st1):]
        thisStart = st2
    elif (st2 < st1):
        seq2 = seq2[(st1-st2):]
        thisStart = st1

    thisEnd = thisStart
    if (len(seq2) > len(seq1)):
        seq2 = seq2[0:len(seq1)]
        thisEnd += len(seq1)
    elif (len(seq1) > len(seq2)):
        seq1 = seq1[0:len(seq2)]
        thisEnd += len(seq2)
    else:
        thisEnd += len(seq1)

    numWindows = int(ceil((thisEnd - thisStart)/skip))
    numTotWin = int(ceil((155260557-59996)/skip))

    curStart = 59996
    faStr = ''
    for i in xrange(numTotWin):
        if curStart < thisStart:
            faStr += 'N'
        elif curStart > thisEnd:
            faStr += 'N'
        else:
            faStr += windowElement(seq1[curStart-thisStart:curStart-thisStart+skip], seq2[curStart-thisStart:curStart-thisStart+skip], miss)
        curStart += skip

    linesize = 100
    o = open(outname, 'w')
    o.write('>\n')
    Curstart = 0
    while(curStart < len(faStr)):
        o.write(faStr[curStart:curStart+linesize])
        o.write('\n')
        curStart += linesize
    o.close()

    # The following line(s) use the Python bindings to upload your file outputs
    # after you have created them on the local file system.  It assumes that you
    # have used the output field name for the filename for each output, but you
    # can change that behavior to suit your needs.

    test = dxpy.upload_local_file(outname);

    # The following line fills in some basic dummy output and assumes
    # that you have created variables to represent your output with
    # the same name as your output fields.

    output = {}
    output["psmcfa"] = dxpy.dxlink(test)

    return output

dxpy.run()
